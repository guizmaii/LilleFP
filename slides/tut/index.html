<!DOCTYPE html>
<html>
<head>
    <title>Pure FP ?</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      table {
        border-collapse: collapse;
      }
      th, td {
        padding: 30px;
        border: 1px solid black;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
      .red { color: red; }
      .bold { font-weight: bold; }
      .center {
        text-align: center;
        margin-left: 5%;
        margin-right: 5%;
      }
      .small { font-size: small; }
      .large { font-size: large; }
    </style>
</head>
<body>
<div id="source">


class: center, middle

# Pure FP ?

 ü§î

### A journey from imperative OO to pure functional programming

Jules Ivanic ‚Ä¢ `@guizmaii`

???
- notes here
- see https://remarkjs.com/#1

---

# Who am I ?

## Jules Ivanic .large[‚Ä¢ `@guizmaii`]

 - 30 years old

 - Professional developer since 5 years.

 - Mostly Scala/FP developer today

 - Ex-CTO @ Colisweb .small[(Ils recrutent: https://www.welcometothejungle.co/fr/companies/colisweb)]

 - Passionate surfer since I'm 11. Leaving to Australia in June üåäüèÑ

???
Empty
---
# Summary

 1. Motivation

 2. Disclaimer

 3. (Synchronous) Imperative OO

 4. Impure FP

 5. Pure FP

 6. Conclusion

 7. Questions

---
class: center, middle

# 1. Motivation

---
# 1. Motivation

TODO.
---
class: center, middle

# 2. Disclaimer

---
# 2. Disclaimer

<br />
<br />
<br />

.center[

![Image](jdg_wisdom.png)

]

???
Apprendre est un processus personnel. Je ne peux rien vous apprendre.
Je peux vous montrer, vous expliquer mais la compr√©hension de ce que je vous montre/explique se passe dans votre t√™te.

Apprendre demande du travail personnel. Vous n'apprenez pas juste en regardant un talk.

Sur des sujets non triviaux, il faut que vous trouviez votre propre "intuition".
C'est cette intuition qui vous permet de comprendre les choses complexes.

Je peux vous partager mon intuition, plus quelques autres si j'en connais d'autres.
Si une de ces intuitions vous parle, cool. Cela va vous permettre de comprendre.
Sinon, il va falloir que vous travailliez pour r√©ussir √† trouver votre propre intuition.
Ce processus peut-√™tre long. Cela d√©pend de plein de param√™tres: du sujet, de votre proximit√© avec celui-ci, etc.

Pour moi, cette notion d'"intuition" est essentiel, c'est pourquoi je tenais √† prendre ces deux minutes pour vous en parler.
---
class: center, middle

# 3. (Synchronous) Imperative OO

---
# 3. (Synchronous) Imperative OO

```java
// I used to write things like that...

class Person {

  private String name;
  private Int age;
  private String address;

  public Person(String name, Int age, String address) {

    if (age < 0 || age > 120) {
      throw new RuntimeException("age is invalid");
    }

    this.name = name; this.age = age; this.address = address;
  }

  public String getName {
    return this.name;
  }

  public void setName(String name) {
    this.name = name;
  }

  ...
}
```
---
# 3. (Synchronous) Imperative OO

```java
// I used to write things like that...

class PersonRepo {

  private DB dbInstance;

  public PersonRepo(DB dbInstance) {
    this.dbInstance = dbInstance;
  }

  public void savePerson(Person p, GpsPoint point) {
    dbInstance.query(
      "INSERT INTO PERSONS (name, age, address, gpsPoint) VALUES (?, ?, ?, ?)",
      p.name, p.age, p.address, point
    )
  }
}

// Or even worst... ü§¢

class PersonRepoSpring {

  @Inject
  private DB instance;

  ...
}
```
---
# 3. (Synchronous) Imperative OO

```java
// I used to write things like that...

class GoogleService {

  private final SyncHttpClient httpClient;

  public GoogleService(SyncHttpClient httpClient) {
    this.httpClient = httpClient;
  }

  public GpsPoint geocode(String address) {
    String res =
      httpClient
        .get("https://api.google.com/geocode/address")
        .body("{ \"address\": \"" + address + "\" }")
        .execute();

    return parse(res);
  }
}
```
---
# 3. (Synchronous) Imperative OO

```java
class Server extends FrameworkMagic {

  private final GoogleService geocoder;
  private final PersonRepo    repo;

  /**
    * Accepted JSON requests:
    *
    * { "name": "Jules", "age": 30, "address": "Sydney, Australia" }
    */
  @Put("/person")
  public HttpResponse createPerson(@Body Person person) {
*    // TODO: Your mission, if you accept, is to code this method.
  }

}
```
---
# 3. (Synchronous) Imperative OO

```java
@Put("/person")
public HttpResponse createPerson(@Body Person person) {

  GpsPoint point = geocoder.geocode(person.address);

  repo.savePerson(person, point);

  return HttpResponse.Created("Done üëç");
}
```
---
# 3. (Synchronous) Imperative OO

```java
@Put("/person")
public HttpResponse createPerson(@Body Person person) {

  GpsPoint point = geocoder.geocode(person.address);

  repo.savePerson(person, point);

  return HttpResponse.Created("Done üëç");
}
```

<br />

.bold[Your nice ignorant boss ü§¥ :]  Nice work. Here's your üíµ

.bold[Me (your CTO) üë®‚Äçüè´ :] You're fired. You waste our money.
---
# 3. (Synchronous) Imperative OO

```java
@Put("/person")
public HttpResponse createPerson(@Body Person person) {

  GpsPoint point = geocoder.geocode(person.address);

  repo.savePerson(person, point);

  return HttpResponse.Created("Done üëç");
}
```

<br />

Problems in this code:
  - No error handling
  - Synchronous
  - Uncontrolled side effects
  - mutable
---
# 3. (Synchronous) Imperative OO

```java
@Put("/person")
public HttpResponse createPerson(@Body Person person) {

  GpsPoint point = geocoder.geocode(person.address);

  repo.savePerson(person, point);

  return HttpResponse.Created("Done üëç");
}
```

<br />

.bold[
Let's improve that piece of code!
]

We'll make it asynchronous and we'll handle errors in the same time

Thanks to ???
---
# [A]synchronous, [non-]blocking ? ü§î

<br />

.center[
|                     | Synchronous                          | Asynchronous                  |
|---------------------|--------------------------------------|-------------------------------|
| .bold[blocking]     | Waste LOTS OF CPU resources          | Unsafe, waste resources       |
| .bold[non-blocking] | Nonsensical                          | Holy Grail üèÜ                 |
]

<br />

[Latency numbers every programmer should know](https://gist.github.com/guizmaii/6395ad8abf1b1718f4a3128fec81f7ce)
---
class: center, middle

# 4. Impure FP

---
# 4. Impure FP

First, let's rewrite the `Person` class ...

```java
class Person {

  private String name;
  private Int age;
  private String address;

  public Person(String name, Int age, String address) {

    if (age < 0 || age > 120) {
      throw new RuntimeException("age is invalid");
    }

    this.name = name; this.age = age; this.address = address;
  }

  public String getName {
    return this.name;
  }

  public void setName(String name) {
    this.name = name;
  }

  ...
}
```
---
# 4. Impure FP

... in Scala

```tut:silent
case class Person(name: String, age: Int, address: String)
```
---
# 4. Impure FP

... in .bold[Scala]

```tut:silent
case class Person(name: String, age: Int, address: String)
```

<br />

.bold[BOOOMM] ü§©
---
# 4. Impure FP

... in .bold[Scala]

```tut:silent
case class Person(name: String, age: Int, address: String)
```

<br />

.bold[BOOOMM] ü§©

But why choose Scala ? Why not stay with Java ?

And also, is this code really equivalent to the previous Java one ?
---
# 4. Impure FP

```tut:silent
case class Person(name: String, age: Int, address: String)

object Person {

  def apply(name: String, age: Int, address: String): Person =
    if (age < 0 || age > 120) throw new RuntimeException("age is invalid")
    else                      new Person(name, age, address)

}

// Usage example:

val jules = Person("Jules", 30, "Sydney, Australia")
```

<br />

Now, it's equivalent to the Java code.
---
# 4. Impure FP

```tut:silent
case class Person(name: String, age: Int, address: String)

object Person {

  def apply(name: String, age: Int, address: String): Person =
    if (age < 0 || age > 120) throw new RuntimeException("age is invalid")
    else                      new Person(name, age, address)

}

// Usage example:

val jules = Person("Jules", 30, "Sydney, Australia")
```

<br />

Now, it's equivalent to the Java code.

.bold[Except that it's immutable] ü§©
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {

  def apply(name: String, age: Int, address: String): `Person` =
    if (age < 0 || age > 120) `throw new RuntimeException("age is invalid")`
    else                      new Person(name, age, address)

}

// Usage example:

val jules = Person("Jules", 30, "Sydney, Australia")
```

<br />

Now, it's equivalent to the Java code.

.bold[Except that it's immutable] ü§©


üë®‚Äçüè´: But with this code, you're still fired!
---
class: center, middle

# Axiom 0

## By default immutability is the absolute minimum you should have in your programming language and its stdlib collections.

#### If a language doesn't offer you that, quit this language!
#### It doesn't worth any effort from you nor anyone.

.right.small[Jules Ivanic]

.left.small[https://twitter.com/guizmaii/status/966370888898744320]
.left.small[https://twitter.com/guizmaii/status/1036580744360062976]
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {

  // bad
  def apply(name: String, ...): Person =
    if (age < 0 || age > 120) throw new RuntimeException("age is invalid")
    else                      new Person(name, age, address)

}
```
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {

  // bad
  def apply(name: String, ...): Person =
    if (age < 0 || age > 120) throw new RuntimeException("age is invalid")
    else                      new Person(name, age, address)

  // better
  def apply2(name: String, ...): Option[Person] =
    if (age < 0 || age > 120) None
    else                      Some(new Person(name, age, address))

}
```
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {

  // bad
  def apply(name: String, ...): Person =
    if (age < 0 || age > 120) throw new RuntimeException("age is invalid")
    else                      new Person(name, age, address)

  // better
  def apply2(name: String, ...): Option[Person] =
    if (age < 0 || age > 120) None
    else                      Some(new Person(name, age, address))

  // Why not
  def apply3(name: String, ...): Either[RuntimeException, Person] =
    if (age < 0 || age > 120) Left(new RuntimeException("age is invalid"))
    else                      Right(new Person(name, age, address))

}
```
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {

  // bad
  def apply(name: String, ...): Person =
    if (age < 0 || age > 120) throw new RuntimeException("age is invalid")
    else                      new Person(name, age, address)

  // better
  def apply2(name: String, ...): Option[Person] =
    if (age < 0 || age > 120) None
    else                      Some(new Person(name, age, address))

  // Why not
  def apply3(name: String, ...): Either[RuntimeException, Person] =
    if (age < 0 || age > 120) Left(new RuntimeException("age is invalid"))
    else                      Right(new Person(name, age, address))

  // Even better
  case class InvalidPersonAge(invalidAge: Int) extends RuntimeException(s"age is invalid: $invalidAge")

  def apply4(name: String, ...): Either[InvalidPersonAge, Person] =
    if (age < 0 || age > 120) Left(InvalidPersonAge(age))
    else                      Right(new Person(name, age, address))

}
```
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {

  // Even better
  case class InvalidPersonAge(invalidAge: Int) extends RuntimeException(s"age is invalid: $invalidAge")

  def apply4(name: String, ...): Either[InvalidPersonAge, Person] =
    if (age < 0 || age > 120) Left(InvalidPersonAge(age))
    else                      Right(new Person(name, age, address))

}
```
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {

  // Even better
  case class InvalidPersonAge(invalidAge: Int) extends RuntimeException(s"age is invalid: $invalidAge")

  def apply4(name: String, ...): Either[InvalidPersonAge, Person] =
    if (age < 0 || age > 120) Left(InvalidPersonAge(age))
    else                      Right(new Person(name, age, address))

  // Holy Grail üèÜ (PCE == PersonCreationException)
  sealed trait `PCE`(message: String) extends RuntimeException(message)
  case class InvalidPersonAge(invalidAge: Int)  extends PCE(s"age is invalid: $invalidAge")
  case class TooDumbNameException(name: String) extends PCE(s"choosed name is too dumb: $name")
  ...

  def applyüèÜ(name: String, ...): Either[`PCE`, Person] =
    if (age < 0 || age > 120)        Left(InvalidPersonAge(age))
    else if (name == "Harry Potter") Left(TooDumbNameException(name))
    ...
    else                             Right(new Person(name, age, address))

}
```
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {
  // Holy Grail üèÜ (PCE == PersonCreationException)
  sealed trait `PCE`(message: String) extends RuntimeException(message)
  case class InvalidPersonAge(invalidAge: Int)  extends PCE(s"age is invalid: $invalidAge")
  case class TooDumbNameException(name: String) extends PCE(s"choosed name is too dumb: $name")
  ...

  def applyüèÜ(name: String, ...): Either[`PCE`, Person] =
    if (age < 0 || age > 120)        Left(InvalidPersonAge(age))
    else if (name == "Harry Potter") Left(TooDumbNameException(name))
    ...
    else                             Right(new Person(name, age, address))
}
```
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {
  // Holy Grail üèÜ (PCE == PersonCreationException)
  sealed trait `PCE`(message: String) extends RuntimeException(message)
  case class InvalidPersonAge(invalidAge: Int)  extends PCE(s"age is invalid: $invalidAge")
  case class TooDumbNameException(name: String) extends PCE(s"choosed name is too dumb: $name")
  ...

  def applyüèÜ(name: String, ...): Either[`PCE`, Person] =
    if (age < 0 || age > 120)        Left(InvalidPersonAge(age))
    else if (name == "Harry Potter") Left(TooDumbNameException(name))
    ...
    else                             Right(new Person(name, age, address))
}
```

What's the problem with throwing exceptions ?

  - Breaks linear execution path
  - Makes methods' signature lie
  - Impossible to know if a method is throwing without reading its code and all the code it calls! .bold[(Takes infinite time)]
  - it's an uncontrolled side effect
---
class: center, middle

# Axiom #1

## With imperative programing, it's impossible to produce a safe and deterministic program in a finite time

.right.small[Jules Ivanic]
---
# 4. Impure FP

```tut:nofail:silent
case class Person(name: String, age: Int, address: String)

object Person {
  // Holy Grail üèÜ (PCE == PersonCreationException)
  sealed trait `PCE`(message: String) extends RuntimeException(message)
  case class InvalidPersonAge(invalidAge: Int)  extends PCE(s"age is invalid: $invalidAge")
  case class TooDumbNameException(name: String) extends PCE(s"choosed name is too dumb: $name")
  ...

  def applyüèÜ(name: String, ...): Either[`PCE`, Person] =
    if (age < 0 || age > 120)        Left(InvalidPersonAge(age))
    else if (name == "Harry Potter") Left(TooDumbNameException(name))
    ...
    else                             Right(new Person(name, age, address))
}
```

<br />

Now that we have our `Person` constructor correctly implemented,
let's continue our refactoring by fixing the `PersonRepo` code.
---
# 4. Impure FP

Reminder: Here's the Java code we'll rewrite ...

```java


class PersonRepo {

  private DB dbInstance;

  public PersonRepo(DB dbInstance) {
    this.dbInstance = dbInstance;
  }

  public void savePerson(Person p, GpsPoint point) {
    dbInstance.query(
      "INSERT INTO PERSONS (name, age, address, gpsPoint) VALUES (?, ?, ?, ?)",
      p.name, p.age, p.address, point
    )
  }
}
```
---
# 4. Impure FP

... in Scala

```tut:invisible
import com.guizmaii.talk.lillefp.Classes._
```

```tut:silent


class PersonRepo(dbInstance: DB) {

  def savePerson(p: Person, point: GpsPoint): Unit =
    dbInstance.query(
      "INSERT INTO PERSONS (name, age, address, gpsPoint) VALUES (?, ?, ?, ?)",
      p.name, p.age, p.address, point
    )

}
```
---
# 4. Impure FP

... in .bold[(blocking synchronous impure FP)] Scala

```tut:invisible
import com.guizmaii.talk.lillefp.Classes._
```

```tut:nofail:silent
import scala.util.Try

class PersonRepo(dbInstance: DB) {

  def savePerson(p: Person, point: GpsPoint): `Try[Unit]` =
    `Try {`
      dbInstance.query(
        "INSERT INTO PERSONS (name, age, address, gpsPoint) VALUES (?, ?, ?, ?)",
        p.name, p.age, p.address, point
      )
    `}`

}
```
---
# 4. Impure FP

... in .bold[(blocking .red[a]synchronous impure FP)] Scala

```tut:invisible
import com.guizmaii.talk.lillefp.Classes._
```

```tut:nofail:silent
import scala.concurrent.{ExecutionContext, Future, blocking}

class PersonRepo(dbInstance: DB) {

  def savePerson(p: Person, point: GpsPoint)`(implicit ex: ExecutionContext)`: `Future[Unit]` =
    `Future {`
      blocking {
        dbInstance.query(
          "INSERT INTO PERSONS (name, age, address, gpsPoint) VALUES (?, ?, ?, ?)",
          p.name, p.age, p.address, point
        )
      }
    `}`

}
```
---
# 4. Impure FP

... in .bold[(.red[non-]blocking .red[a]synchronous impure FP)] Scala

```tut:invisible
import com.guizmaii.talk.lillefp.Classes._
```

```tut:nofail:silent
import scala.concurrent.{ExecutionContext, Future}

class PersonRepo(dbInstance: `AsyncNIODB`) { // NIO == Non-blocking IO, in JVM slang

  def savePerson(p: Person, point: GpsPoint)(implicit ex: ExecutionContext): `Future[Unit]` =
    dbInstance.query(
      "INSERT INTO PERSONS (name, age, address, gpsPoint) VALUES (?, ?, ?, ?)",
      p.name, p.age, p.address, point
    )

}
```
---
# 4. Impure FP

Now, let's do quickly the same thing for the `GoogleService`.

Reminder: Here's the Java code we'll rewrite ...

```java


class GoogleService {

  private final SyncHttpClient httpClient;

  public GoogleService(SyncHttpClient httpClient) {
    this.httpClient = httpClient;
  }

  public GpsPoint geocode(String address) {
    String res =
      httpClient
        .get("https://api.google.com/geocode/address")
        .body("{ \"address\": \"" + address + "\" }")
        .execute();

    return parse(res);
  }
}
```
---
# 4. Impure FP

... in .bold[(.red[non-]blocking .red[a]synchronous impure FP)] Scala

<br />

```tut:invisible
import com.guizmaii.talk.lillefp.Classes._
```

```tut:nofail:silent
import scala.concurrent.{ExecutionContext, Future}

class GoogleService(httpClient: `AsyncNIOHttpClient`) { // NIO == Non-blocking IO, in JVM slang

  def geocode(address: String)(implicit ex: ExecutionContext): `Future[GpsPoint]` =
    httpClient
      .get("https://api.google.com/geocode/address")
      .body("{ \"address\": \"" + address + "\" }")
      .execute()
      `.map(res: String => parse(res))`

}
```
---
# 4. Impure FP

... in .bold[(.red[non-]blocking .red[a]synchronous impure FP)] Scala

<br />

```tut:invisible
import com.guizmaii.talk.lillefp.Classes._
```

```tut:nofail:silent
import scala.concurrent.{ExecutionContext, Future}

class GoogleService(httpClient: `AsyncNIOHttpClient`) { // NIO == Non-blocking IO, in JVM slang

  def geocode(address: String)(implicit ex: ExecutionContext): `Future[GpsPoint]` =
    httpClient
      .get("https://api.google.com/geocode/address")
      .body("{ \"address\": \"" + address + "\" }")
      .execute()
      `.map(parse)`  // 'parse' signature: String => GpsPoint

}
```
---
# Conclusion


FP helps me to write more declarative code.

Pure FP help me to write more composable code.
---
class: center, middle

# Thanks!
Code and slides at `guizmaii/LilleFP` on GitHub

## Questions?


</div>
<script src="remark-latest.min.js">
</script>
<script>
  const slideshow = remark.create({
    ratio: "16:9", // 4:3

    highlightStyle: "github",
    highlightLines: true,
    highlightSpans: true,
  });
</script>
</body>
</html>
